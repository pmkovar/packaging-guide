<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chap-Advanced_Topics">
  <title>Advanced Topics</title>
  <para>This chapter discusses advanced topics on packaging &DSCL;s.</para>
  <section id="sect-Using_Software_Collections_over_NFS">
    <title>Using &DSCL;s over NFS</title>
    <para>In some environments, the requirement is often to have a centralized model for how applications and tools are distributed rather than allowing users to install the application or tool version they prefer. In this way, NFS is the common method of mounting centrally managed software.</para>
    <para>You need to define a &DSCL; macro <code>nfsmountable</code> to use a &DSCL; over NFS. If the macro is defined when building a &DSCL;, the resulting &DSCL; has its state files and configuration files located outside the &DSCL;'s <filename>/opt</filename> file system hierarchy. This enables you to mount the <filename>/opt</filename> file system hierarchy over NFS as read-only.</para>
    <para>To define the <code>nfsmountable</code> macro, ensure that the &DSCL; metapackage spec file contains the following lines:</para>
    <programlisting language="RPM Spec">%global nfsmountable 1

%scl_package %scl</programlisting>
    <para>As shown above, the <code>nfsmountable</code> macro must be defined before defining the <code>%scl_package</code> macro. This is because the <code>%scl_package</code> macro redefines the <code>_sysconfdir</code>, <code>_sharedstatedir</code>, and <code>_localstatedir</code> macros depending on whether the <code>nfsmountable</code> macro has been defined or not. The values that <code>nfsmountable</code> changes for the redefined macros are detailed in the following table.</para>
        <table>
        <title>Changed Values for &DSCL; Macros</title>
        <tgroup cols="5">
          <thead>
            <row rowsep="1">
              <entry colsep="1" rowsep="1">
                <para>Macro</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>Original definition</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>Expanded value for the original definition</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>Changed definition</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>Expanded value for the changed definition</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row rowsep="1">
              <entry colsep="1" rowsep="1">
                <para>
                  <code>_sysconfdir</code>
                </para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_scl_root}/etc</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/&OPT;/&RH;/%{scl}/root/etc</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_root_sysconfdir}%{_scl_prefix}/scls/%{scl}</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/etc/&OPT;/&RH;/scls/%{scl}</para>
              </entry>
            </row>
            <row rowsep="1">
              <entry colsep="1" rowsep="1">
                <para>
                  <code>_sharedstatedir</code>
                </para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_scl_root}/var/lib</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/&OPT;/&RH;/%{scl}/root/var/lib</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_root_localstatedir}%{_scl_prefix}/scls/%{scl}/lib</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/var/&OPT;/&RH;/scls/%{scl}/lib</para>
              </entry>
            </row>
            <row rowsep="1">
              <entry colsep="1" rowsep="1">
                <para>
                  <code>_localstatedir</code>
                </para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_scl_root}/var</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/&OPT;/&RH;/%{scl}/root/var</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>%{_root_localstatedir}%{_scl_prefix}/scls/%{scl}</para>
              </entry>
              <entry colsep="1" rowsep="1">
                <para>/var/&OPT;/&RH;/scls/%{scl}</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Note that the expanded values for the changed definitions contain a <filename>/scls</filename> directory in their paths.</para>
      <section id="sect-Changed_Directory_Structure_and_File_Ownership">
      <title>Changed Directory Structure and File Ownership</title>
      <para>The <code>nfsmountable</code> macro also has an impact on how the <code>scl_install</code> and <code>scl_files</code> macros create a directory structure and set the file ownership when you run the <command>rpmbuild</command> command.</para>
      <para>For example, a directory structure of a &DSCL; named <application>software_collection</application> with the <code>nfsmountable</code> macro defined looks as follows:</para>
      <screen><computeroutput>$ </computeroutput><userinput>rpmbuild -ba software_collection.spec --define 'scl software_collection'</userinput>
...
<computeroutput>$ </computeroutput><userinput>rpm -qlp software_collection-runtime-1-1.&PKGOS;.x86_64</userinput>
/etc/&OPT;/&RH;/scls/software_collection
/etc/&OPT;/&RH;/scls/software_collection/X11
/etc/&OPT;/&RH;/scls/software_collection/X11/applnk
/etc/&OPT;/&RH;/scls/software_collection/X11/fontpath.d
...
/&OPT;/&RH;/software_collection/root/usr/src
/&OPT;/&RH;/software_collection/root/usr/src/debug
/&OPT;/&RH;/software_collection/root/usr/src/kernels
/&OPT;/&RH;/software_collection/root/usr/tmp
/var/&OPT;/&RH;/scls/software_collection
/var/&OPT;/&RH;/scls/software_collection/cache
/var/&OPT;/&RH;/scls/software_collection/db
/var/&OPT;/&RH;/scls/software_collection/empty
...</screen>
      </section>
      <section id="sect-Registering_and_Deregistering_Software_Collections">
        <title>Registering and Deregistering &DSCL;s</title>
        <para>In case a &DSCL; is shared over NFS but not locally installed on your system, you need to make the <application>scl</application> tool aware of it by registering that &DSCL;.</para>
        <para>Registering a &DSCL; is done by running the <command>scl register</command> command:</para>
        <screen><computeroutput>$ </computeroutput>scl register <replaceable>/&OPT;/&RH;/software_collection</replaceable></screen>
        <para>where <replaceable>/&OPT;/&RH;/software_collection</replaceable> is the absolute path to the file system hierarchy of the &DSCL; you want to register. The path's directory must contain the <filename>enable</filename> scriptlet and the <filename>root/</filename> directory to be considered a valid &DSCL; file system hierarchy.</para>
        <para>Deregistering a &DSCL; is a reverse operation that you perform when you no longer want the <application>scl</application> tool to be aware of a registered &DSCL;.</para>
                <para>Deregistering a &DSCL; is done by calling a <literal>deregister</literal> scriptet when running the <command>scl</command> command:</para>
        <screen><computeroutput>$ </computeroutput>scl deregister <replaceable>software_collection</replaceable></screen>
        <para>where <replaceable>software_collection</replaceable> is the name of the &DSCL; you want to deregister.</para>
        <section id="sect-Using_deregister_Scriptlets_in_a_Software_Collection_Metapackage">
          <title>Using (de)register Scriptlets in a &DSCL; Metapackage</title>
          <para>You can specify (de)register scriptlets in a &DSCL; metapackage similarly to how enable scriptlets are specified. When specifying the scriptets, remember to explicitly include them in the <code>%file</code> section of the metapackage spec file.</para>
          <para>See the following sample code for an example of specifying (de)register scriptets:</para>
          <programlisting language="RPM Spec"><![CDATA[%install
%scl_install

cat >> %{buildroot}%{_scl_scripts}/enable << EOF
# Contents of the enable scriptlet goes here
...
EOF

cat >> %{buildroot}%{_scl_scripts}/register << EOF
# Contents of the register scriptlet goes here
...
EOF

cat >> %{buildroot}%{_scl_scripts}/deregister << EOF
# Contents of the deregister scriptlet goes here
...
EOF
...
%files runtime
%scl_files
%{_scl_scripts}/register
%{_scl_scripts}/deregister]]></programlisting>
          <para>In the register scriptlet, you can optionally specify the commands you want to run when registering the &DSCL;, for example, commands to create files in <filename>/etc/opt/</filename> or <filename>/var/opt/</filename>.</para>
        </section>
      </section>
  </section>
  <section id="sect-Converting_Software_Collection_Scriptlets_into_Environment_Modules">
    <title>Converting &DSCL; Scriptlets into Environment Modules</title>
    <para>Environment modules allow you to manage, for example, different versions of applications by dynamically modifying your shell environment. To use your &DSCL; with the environment module system, convert the &DSCL;'s <filename>enable</filename> scriptlet into an environment module with a script <filename>/usr/share/Modules/bin/createmodule.sh</filename>.</para>
    <procedure>
      <title>Converting an enable scriptlet into an environment module</title>
      <step>
        <para>Ensure that an <package>environment-modules</package> package is installed on your system:</para>
        <screen><computeroutput># </computeroutput><userinput>yum install environment-modules</userinput></screen>
      </step>
      <step>
        <para>Run the <filename>/usr/share/Modules/bin/createmodule.sh</filename> script to convert your &DSCL;'s <filename>enable</filename> scriptlet into an environment module:</para>
        <screen><command>/usr/share/Modules/bin/createmodule.sh <replaceable>/path/to/enable/scriptlet</replaceable></command></screen>
        <para>Replace <replaceable>/path/to/enable/scriptlet</replaceable> with the file path of the <filename>enable</filename> scriptlet you want to convert.</para>
      </step>
      <step>
        <para>Add the same command <command>/usr/share/Modules/bin/createmodule.sh <replaceable>/path/to/enable/scriptlet</replaceable></command> in the <code> %pre</code> section of your &DSCL; metapackage, below the code generating your <filename>enable</filename> scriptlet.</para>
        <para>In case you have the <filename>enable</filename> scriptlet packaged as a file in one of your &DSCL; packages, add the command <command>/usr/share/Modules/bin/createmodule.sh <replaceable>/path/to/enable/scriptlet</replaceable></command> in the <code>%post</code> section.</para>
      </step>
    </procedure>
    <para>See the <emphasis role="bold">module</emphasis>(1) manual page for more information about environment modules.</para>
  </section>
  <section id="sect-Packaging_Wrappers_for_Software_Collections">
    <title>Packaging Wrappers for &DSCL;s</title>
    <para>
      Using wrappers is an easy way to shorten commands that the user runs in the &DSCL; environment.</para>
     <para>The following is an example of a wrapper from a Ruby-based &DSCL; named <package>rubyscl</package> that is installed as <filename>/usr/bin/rubyscl-ruby</filename> and allows the user to run <command>rubyscl-ruby <replaceable>command</replaceable></command> instead of <command>scl enable rubyscl 'ruby <replaceable>command</replaceable>'</command>:
    </para>
    <programlisting language="Bash">#!/bin/bash

COMMAND="ruby $@"
scl enable rubyscl "$COMMAND"
</programlisting>
<para>
  It is important to package these wrappers as subpackages of the &DSCL; package that will use them. That way, you can make installation of these wrappers optional, allowing the user not to install them, for example, on systems with read-only access to the <filename>/usr/bin/</filename> directory where the wrappers would otherwise be installed.
</para>
  </section>
  <section id="sect-Software_Collection_Initscript_Support">
    <title>Managing Services in &DSCL;s</title>
    <para>When packaging your &DSCL;, ensure that users can directly manage any services (daemons) provided by the &DSCL; or one of the associated applications with the system default tools, like <command>service</command> or <command>chkconfig</command> on Red Hat Enterprise Linux 6, or <command>systemctl</command> on Red Hat Enterprise Linux 7.</para>
    <para>For &DSCL;s on Red Hat Enterprise Linux 6, make sure to adjust the <code>%install</code> section of the spec file as follows to avoid possible name conflicts with the system versions of the services that are part of the &DSCL;:</para>
    <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/rc.d/init.d/%{?scl_prefix}<replaceable>service_name</replaceable></programlisting>
    <para>Replace <replaceable>service_name</replaceable> with the actual name of the service.</para>
    <para>For &DSCL;s on Red Hat Enterprise Linux 7, adjust the <code>%install</code> section of the spec file as follows:</para>
    <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{_unitdir}/%{?scl_prefix}<replaceable>service_name</replaceable>.service</programlisting>
    <para>With this configuration in place, you can then refer to the version of the service included in the &DSCL; as follows:</para>
    <screen>%{?scl_prefix}<replaceable>service_name</replaceable></screen>
    <para>Keep in mind that no environment variables are propagated from the user's environment to a SysV init script (or a systemd service file on Red Hat Enterprise Linux 7). This is expected and ensures that services are always started in a clean environment. However, this requires you to properly set up a &DSCL; environment for processes that are to be run by the SysV init scripts (or systemd service files).</para>
    <section id="sect-Configuring_an_Environment_for_Services">
    <title>Configuring an Environment for Services</title>
    <para>It is recommended to make the &DSCL; you want to enable for services configurable. The directions in this section show how to make a &DSCL; named <replaceable>software_collection</replaceable> configurable.</para>
    <procedure>
      <title>Configuring an environment for services on Red Hat Enterprise Linux 6</title>
      <step>
        <para>Create a configuration file in <filename>/&OPT;/&RH;/<replaceable>software_collection</replaceable>/service-environment</filename> with the following content:</para>
        <programlisting>[<replaceable>SCLNAME</replaceable>]_SCLS_ENABLED="<replaceable>software_collection</replaceable>"</programlisting>
        <para>Replace <replaceable>SCLNAME</replaceable> with a unique identifier for your &DSCL;, for instance, your &DSCL;'s name written in capital letters.</para>
        <para>Replace <replaceable>software_collection</replaceable> with the name of your &DSCL; as defined by the <code>
%scl_name</code> macro.</para>
      </step>
      <step>
        <para>Add the following line at the beginning of the SysV init script:</para>
        <programlisting>source /&OPT;/&RH;/<replaceable>software_collection</replaceable>/service-environment</programlisting>
      </step>
      <step>
        <para>In the SysV init script, determine commands that run binaries located in the <filename>/&OPT;/&RH;/</filename> file system hierarchy. Prefix these commands with <command>scl enable $[SCLNAME]_SCLS_ENABLED</command>, similarly to when you run a command in the &DSCL; environment.</para>
        <para>For example, replace the following line:</para>
        <programlisting>/usr/bin/daemon_binary --argument-1 --argument-2</programlisting>
        <para>with:</para>
        <programlisting>scl enable $[SCLNAME]_SCLS_ENABLED -- /usr/bin/daemon_binary --argument-1 --argument-2</programlisting>
      </step>
      <step>
        <para>Some commands, like <command>su</command> or <command>runuser</command>, also clear environment variables. Thus, if these commands are used in the SysV init script, enable your &DSCL; again after running these commands.</para>
        <para>For instance, replace the following line:</para>
        <programlisting>su - user_name -c '/usr/bin/daemon_binary --argument-1 --argument-2'</programlisting>
        <para>with:</para>
        <programlisting>su - user_name -c '\
  source /&OPT;/&RH;/software_collection/service-environment \
  scl enable $SCLNAME_SCLS_ENABLED -- /usr/bin/daemon_binary --argument-1 --argument-2'</programlisting>
      </step>
    </procedure>
    <procedure>
      <title>Configuring an environment for services on Red Hat Enterprise Linux 7</title>
      <step>
        <para>Create a configuration file in <filename>/&OPT;/&RH;/<replaceable>software_collection</replaceable>/service-environment</filename> with the following content:</para>
        <programlisting>[<replaceable>SCLNAME</replaceable>]_SCLS_ENABLED="<replaceable>software_collection</replaceable>"</programlisting>
        <para>Replace <replaceable>SCLNAME</replaceable> with a unique identifier for your &DSCL;, for instance, your &DSCL;'s name written in capital letters.</para>
        <para>Replace <replaceable>software_collection</replaceable> with the name of your &DSCL; as defined by the <code>
%scl_name</code> macro.</para>
      </step>
      <step>
        <para>Add the following line in the systemd service file to load the configuration file:</para>
        <programlisting>EnvironmentFile=/&OPT;/&RH;/software_collection/service-environment</programlisting>
      </step>
      <step>
        <para>In the systemd service file, prefix all commands specified in <option>ExecStartPre</option>, <option>ExecStart</option>, and similar directives with <command>scl enable $[SCLNAME]_SCLS_ENABLED</command>, similarly to when you run a command in the &DSCL; environment:</para>
        <programlisting>ExecStartPre=/usr/bin/scl enable $[SCLNAME]_SCLS_ENABLED -- /&OPT;/&RH;/software_collection/root/usr/bin/daemon_helper_binary --argument-1 --argument-2
ExecStart=/usr/bin/scl enable $[SCLNAME]_SCLS_ENABLED -- /opt/provider/software_collection/root/usr/bin/daemon_binary --argument-1 --argument-2</programlisting>
      </step>
    </procedure>
  </section>
  </section>
  <section id="sect-Software_Collection_Library_Support">
    <title>&DSCL; Library Support</title>
    <para>In case you distribute libraries that you intend to use only in the &DSCL; environment or in addition to the libraries available on the system, update the <envar>LD_LIBRARY_PATH</envar> environment variable in the <filename>enable</filename> scriptlet as follows:</para>
    <programlisting language="RPM Spec">export LD_LIBRARY_PATH=%{_libdir}${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}</programlisting>
    <para>The configuration ensures that the version of the library in the &DSCL; is preferred over the version of the library available on the system if the &DSCL; is enabled.</para>
    <note>
      <para>
        In case you distribute a private shared library in the &DSCL;, consider using the <envar>DT_RUNPATH</envar> attribute instead of the <envar>LD_LIBRARY_PATH</envar> environment variable to make the private shared library accessible in the &DSCL; environment.
      </para>
    </note>
    <section id="sect-Using_a_Library_Outside_of_the_Collection">
  <title>Using a Library Outside of the &DSCL;</title>
    <para>If you distribute libraries that you intend to use outside of the &DSCL; environment, you can use the directory <filename>/etc/ld.so.conf.d/</filename> for this purpose.</para>
    <warning>
      <para>Do not use <filename>/etc/ld.so.conf.d/</filename> for libraries already available on the system. Using <filename>/etc/ld.so.conf.d/</filename> is only recommended for a library that is not available on the system, as otherwise the version of the library in the &DSCL; might get preference over the system version of the library. That could lead to undesired behavior of the system versions of the applications, including unexpected termination and data loss.</para>
    </warning>
    <procedure>
      <title>Using /etc/ld.so.conf.d/ for libraries in the &DSCL;</title>
      <step>
        <para>Create a file named <filename>%{?scl_prefix}libs.conf</filename> and adjust the spec file configuration accordingly:</para>
        <programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}libs.conf
</programlisting>
      </step>
      <step>
        <para>In the <filename>%{?scl_prefix}libs.conf</filename> file, include a list of directories where the versions of the libraries associated with the &DSCL; are located. For example:</para>
        <programlisting>/&OPT;/&RH;/software_collection_1/root/usr/lib64/
</programlisting>
        <para>In the example above, the <filename>/usr/lib64/</filename> directory that is part of the &DSCL; <application>software_collection_1</application> is included in the list.</para>
      </step>
      <step>
        <para>Edit the <code>%install</code> section of the spec file, so the <filename>%{?scl_prefix}libs.conf</filename> file is installed as follows:</para>
        <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/ld.so.conf.d/
</programlisting>
      </step>
    </procedure>
    </section>
    <section id="sect-Prefixing_the_Library_Major_soname_with_the_Collection_Name">
    <title>Prefixing the Library Major soname with the &DSCL; Name</title>
    <para>
      When using libraries included in the &DSCL;, always remember that a library with the same major soname can already be available on the system as a part of the base system installation. It is thus important not to forget to use the <command>scl enable</command> command when building an application against a library included in the &DSCL;. Failing to do so may result in the application being executed in an incorrect environment, linked against the incorrect system version of the library.</para>
    <warning>
      <para>Keep in mind that executing your application in an incorrect environment (for example in the system environment instead of the &DSCL; environment) as well as linking your application against an incorrect library can lead to undesired behavior of your application, including unexpected termination and data loss.</para>
    </warning>
<para>To ensure that your application is not linked against an incorrect library even if the <envar>LD_LIBRARY_PATH</envar> environment variable has not been set properly, change the major soname of the library included in the &DSCL;. The recommended way to change the major soname is to prefix the major soname version number with the &DSCL; name.
</para>
<para>
  Below is an example of the MySQL client library with the <literal>mysql55-</literal> prefix:
</para>
<screen><computeroutput>$ </computeroutput><userinput>rpm -ql mysql55-mysql-libs | grep 'lib.*so'</userinput>
/&OPT;/&RH;/mysql55/root/usr/lib64/mysql/libmysqlclient.so.mysql55-18
/&OPT;/&RH;/mysql55/root/usr/lib64/mysql/libmysqlclient.so.mysql55-18.0.0</screen>
<para>
  On the same system, the system version of the MySQL client library is listed below:
</para>
<screen>
$ <command>rpm -ql mysql-libs | grep 'lib.*so'</command>
/usr/lib64/mysql/libmysqlclient.so.18
/usr/lib64/mysql/libmysqlclient.so.18.0.0
</screen>
<para>The <command>rpmbuild</command> utility generates an automatic <code>Provides</code> tag for packages that include a versioned shared library. If you do not prefix the soname as described above, then an example of the <code>Provides</code> in case of the <package>mysql</package> package is <code>libmysqlclient.so.18()(64bit)</code>. With this <code>Provides</code>, RPM can choose the incorrect RPM package, resulting in the application missing the requirement.</para>
<para>
  If you prefix the soname as described above, then an example of the generated <code>Provides</code> in case of <package>mysql</package> is <code>libmysqlclient.so.mysql55-18()(64bit)</code>. With this <code>Provides</code>, RPM chooses the correct RPM dependencies and the application's requirements are satisfied.
</para>
<para>
  In general, unless absolutely necessary, &DSCL; packages should not provide any symbols that are already provided by packages from the base system installation. One exception to that rule is when you want to use the symbols in the packages from the base system installation.
</para>
</section>
<section id="sect-Software_Collection_Library_Support_in_Red_Hat_Enterprise_Linux_7">
  <title>&DSCL; Library Support in Red Hat Enterprise Linux 7</title>
  <para>
    When building your &DSCL; for Red Hat Enterprise Linux 7, use the <systemitem>%__provides_exclude_from</systemitem> macro to prevent scanning certain files for automatically generated RPM symbols.
  </para>
  <para>For example, to prevent scanning <filename>.so</filename> files in the <systemitem>%{_libdir}</systemitem> directory, add the following lines before the <code>BuildRequires</code> or <code>Requires</code> tags in your &DSCL; spec file:
  </para>
  <programlisting language="RPM Spec">%if %{?scl:1}%{!?scl:0}
  # Do not scan .so files in %{_libdir}
  %global __provides_exclude_from ^%{_libdir}/.*.so.*$
%endif</programlisting>
  <para>
    The functionality is part of RPM support for automatic <code>Provides</code> and <code>Requires</code>, see <xref linkend="sect-Software_Collection_Automatic_Provides_Requires_Filtering_Support" /> for more information.
  </para>
</section>
  </section>
<section id="sect-Software_Collection_pc_Files_Support">
    <title>&DSCL; .pc Files Support</title>
    <para>The .pc files are special metadata files used by the <application>pkg-config</application> program to store information about libraries available on the system.</para>
    <para>In case you distribute .pc files that you intend to use only in the &DSCL; environment or in addition to the .pc files installed on the system, update the <envar>PKG_CONFIG_PATH</envar> environment variable. Depending on what is defined in your .pc files, update the <envar>PKG_CONFIG_PATH</envar> environment variable for the <varname>%{_libdir}</varname> macro (which expands to the library directory, typically <filename>/usr/lib/</filename> or <filename>/usr/lib64/</filename>), or for the <varname>%{_datadir}</varname> macro (which expands to the share directory, typically <filename>/usr/share/</filename>).</para>
    <para>If the library directory is defined in your .pc files, update the <envar>PKG_CONFIG_PATH</envar> environment variable by adjusting the <code>%install</code> section of the &DSCL; spec file as follows:</para>
    <programlisting language="RPM Spec"><![CDATA[%install
cat >> %{buildroot}%{_scl_scripts}/enable << EOF
export PKG_CONFIG_PATH=%{_libdir}/pkgconfig:\$PKG_CONFIG_PATH
EOF]]></programlisting>
    <para>If the share directory is defined in your .pc files, update the <envar>PKG_CONFIG_PATH</envar> environment variable by adjusting the <code>%install</code> section of the &DSCL; spec file as follows:</para>
    <programlisting language="RPM Spec"><![CDATA[%install
cat >> %{buildroot}%{_scl_scripts}/enable << EOF
export PKG_CONFIG_PATH=%{_datadir}/pkgconfig:\$PKG_CONFIG_PATH
EOF]]></programlisting>
    <para>The two examples above both configure the <filename>enable</filename> scriptlet so that it ensures that the .pc files in the &DSCL; are preferred over the .pc files available on the system if the &DSCL; is enabled.</para>
    <para>The &DSCL; can provide a wrapper script that is visible to the system to enable the &DSCL;, for example in the <filename>/usr/bin/</filename> directory. In this case, ensure that the .pc files are visible to the system even if the &DSCL; is disabled.</para>
    <para>To allow your system to use .pc files from the disabled &DSCL;, update the <envar>PKG_CONFIG_PATH</envar> environment variable with the paths to the .pc files associated with the &DSCL;. Depending on what is defined in your .pc files, update the <envar>PKG_CONFIG_PATH</envar> environment variable for the <varname>%{_libdir}</varname> macro (which expands to the library directory), or for the <varname>%{_datadir}</varname> macro (which expands to the share directory).</para>
<procedure><title>Updating the PKG_CONFIG_PATH environment variable for %{_libdir}</title>
<step><para>To update the <envar>PKG_CONFIG_PATH</envar> environment variable for the <varname>%{_libdir}</varname> macro, create a custom script <filename>/etc/profile.d/<replaceable>name.sh</replaceable></filename>. The script is preloaded when a shell is started on the system.</para>
<para>For example, create the following file:</para>
    <screen>%{?scl_prefix}pc-libdir.sh</screen></step>
<step><para>Use the <filename>pc-libdir.sh</filename> short script that modifies the <envar>PKG_CONFIG_PATH</envar> variable to refer to your .pc files:</para>
    <screen>export PKG_CONFIG_PATH=%{_libdir}/pkgconfig:/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection/path/to/your/pc_files</replaceable></screen></step>
<step><para>Add the file to your &DSCL; package's spec file:</para>
<programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}pc-libdir.sh</programlisting></step>
    <step><para>Install this file into the system <filename>/etc/profile.d/</filename> directory by adjusting the <code>%install</code> section of the &DSCL; package's spec file:</para>
    <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/profile.d/</programlisting>
</step>
</procedure>
<procedure><title>Updating the PKG_CONFIG_PATH environment variable for %{_datadir}</title>
<step><para>To update the <envar>PKG_CONFIG_PATH</envar> environment variable for the <varname>%{_datadir}</varname> macro, create a custom script <filename>/etc/profile.d/<replaceable>name.sh</replaceable></filename>. The script is preloaded when a shell is started on the system.</para>
<para>For example, create the following file:</para>
    <screen>%{?scl_prefix}pc-datadir.sh</screen></step>
<step><para>Use the <filename>pc-datadir.sh</filename> short script that modifies the <envar>PKG_CONFIG_PATH</envar> variable to refer to your .pc files:</para>
    <screen>export PKG_CONFIG_PATH=%{_datadir}/pkgconfig:/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection/path/to/your/pc_files</replaceable></screen></step>
<step><para>Add the file to your &DSCL; package's spec file:</para>
<programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}pc-datadir.sh</programlisting></step>
    <step><para>Install this file into the system <filename>/etc/profile.d/</filename> directory by adjusting the <code>%install</code> section of the &DSCL; package's spec file:</para>
    <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/profile.d/</programlisting>
</step>
</procedure>
</section>
  <section id="sect-Software_Collection_manpath_Support">
    <title>&DSCL; MANPATH Support</title>
    <para>To allow the <command>man</command> command on the system to display manual pages from the enabled &DSCL;, update the <envar>MANPATH</envar> environment variable with the paths to the manual pages that are associated with the &DSCL;.</para>
    <para>To update the <envar>MANPATH</envar> environment variable, add the following to the <code>%install</code> section of the &DSCL; spec file:</para>
    <programlisting language="RPM Spec"><![CDATA[%install
cat >> %{buildroot}%{_scl_scripts}/enable << EOF
export MANPATH=%{_mandir}:\${MANPATH}
EOF]]></programlisting>
    <para>This configures the <filename>enable</filename> scriptlet to update the <envar>MANPATH</envar> environment variable. The manual pages associated with the &DSCL; are then not visible as long as the &DSCL; is not enabled.</para>
    <para>The &DSCL; can provide a wrapper script that is visible to the system to enable the &DSCL;, for example in the <filename>/usr/bin/</filename> directory. In this case, ensure that the manual pages are visible to the system even if the &DSCL; is disabled.</para>
    <para>To allow the <command>man</command> command on the system to display manual pages from the disabled &DSCL;, update the <envar>MANPATH</envar> environment variable with the paths to the manual pages associated with the &DSCL;.</para>
<procedure><title>Updating the MANPATH environment variable for the disabled &DSCL;</title>
<step><para>To update the <envar>MANPATH</envar> environment variable, create a custom script <filename>/etc/profile.d/<replaceable>name.sh</replaceable></filename>. The script is preloaded when a shell is started on the system.</para>
<para>For example, create the following file:</para>
    <screen>%{?scl_prefix}manpage.sh</screen></step>
    <step>
    <para>Use the <filename>manpage.sh</filename> short script that modifies the <envar>MANPATH</envar> variable to refer to your man path directory:</para>
    <screen>export MANPATH=/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection/path/to/your/man_pages</replaceable>:${MANPATH}</screen>
    </step>
    <step><para>Add the file to your &DSCL; package's spec file:</para>
    <programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}manpage.sh</programlisting></step>
    <step><para>Install this file into the system <filename>/etc/profile.d/</filename> directory by adjusting the <code>%install</code> section of the &DSCL; package's spec file:</para>
    <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/profile.d/</programlisting>
</step>
</procedure>
  </section>
  <section id="sect-Software_Collection_cronjob_Support">
    <title>&DSCL; cronjob Support</title>
    <para>With your &DSCL;, you can run periodic tasks on the system either with a dedicated service or with cronjobs. If you intend to use a dedicated service, refer to <xref linkend="sect-Software_Collection_Initscript_Support"/> on how to work with initscripts in the &DSCL; environment.</para>
    <procedure>
      <title>Running periodic tasks with cronjobs</title>
      <step>
        <para>To use cronjobs for running periodic tasks, place a <filename>crontab</filename> file for your &DSCL; in the <filename>/etc/cron.d/</filename> directory with the &DSCL;'s name.</para>
        <para>For example, create the following file:</para>
        <screen>%{?scl_prefix}crontab</screen>
      </step>
      <step>
        <para>Ensure that the contents of the <filename>crontab</filename> file follow the standard <filename>crontab</filename> file format, as in the following example:</para>
        <screen>0 1 * * Sun root scl enable <replaceable>software_collection</replaceable> '<filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/root/usr/bin/<replaceable>cron_job_name</replaceable></filename>'</screen>
        <para>where <replaceable>software_collection</replaceable> is the name of your &DSCL;, and <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/root/usr/bin/<replaceable>cron_job_name</replaceable></filename> is the command you want to periodically run.</para>
      </step>
      <step>
        <para>Add the file to your spec file of the &DSCL; package:</para>
        <programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}crontab</programlisting>
      </step>
      <step>
        <para>Install the file into the system directory <filename>/etc/cron.d/</filename> by adjusting the <code>%install</code> section of the &DSCL; package's spec file:</para>
        <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/cron.d/
</programlisting>
      </step>
    </procedure>
  </section>
  <section id="sect-Software_Collection_Log_File_Support">
    <title>&DSCL; Log File Support</title>
    <!--para>&DSCL;s should store their log files in <filename>%{_localstatedir}/log/<replaceable>original-path</replaceable>/</filename> where <replaceable>original-path</replaceable> </para-->
    <para>By default, programs packaged in a &DSCL; create log files in the <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/root/var/log/</filename> directory.</para>
    <para>To make the log files more accessible and easier to manage, you are strongly advised to use the <code>nfsmountable</code> macro that redefines the <code>_localstatedir</code> macro. This results in the log file being created underneath the <filename>/var/opt/</filename> directory, outside of the <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/</filename> file system hierarchy.</para>
    <para>For example, a service <replaceable>mydaemon</replaceable> normally stores its log file in <filename>/var/log/mydaemon/mydaemond.log</filename> in the base system installation. When <replaceable>mydaemon</replaceable> is packaged as a <replaceable>software_collection</replaceable> &DSCL; and the <code>nfsmountable</code> macro is defined, the path to the log file in <replaceable>software_collection</replaceable> is as follows:</para>
    <screen><filename>/var/opt/&OPT;/scls/<replaceable>software_collection</replaceable>/log/mydaemon/mydaemond.log</filename></screen>
    <para>For more information on using the <code>nfsmountable</code> macro, see <xref linkend="sect-Using_Software_Collections_over_NFS" />.</para>
  </section>
  <section id="sect-Software_Collection_logrotate_Support">
    <title>&DSCL; logrotate Support</title>
    <para>With your &DSCL; or an application associated with your &DSCL;, you can manage log files with the <application>logrotate</application> program.</para>
    <procedure>
      <title>Managing log files with logrotate</title>
      <step>
        <para>To manage your log files with <application>logrotate</application>, place a custom <application>logrotate</application> file for your &DSCL; in the system directory for the <application>logrotate</application> jobs <filename>/etc/logrotate.d/</filename>.</para>
        <para>For example, create the following file:</para>
        <screen>%{?scl_prefix}logrotate</screen>
      </step>
      <step>
        <para>Ensure that the contents of the <filename>logrotate</filename> file follow the standard <filename>logrotate</filename> file format as follows:</para>
        <screen>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/var/log/<replaceable>your_application_name</replaceable>.log {
      missingok
      notifempty
      size 30k
      yearly
      create 0600 root root
  }</screen>
      </step>
      <step>
        <para>Add the file to your spec file of the &DSCL; package:</para>
        <programlisting language="RPM Spec">SOURCE2: %{?scl_prefix}logrotate</programlisting>
      </step>
      <step>
        <para>Install the file into the system directory <filename>/etc/logrotate.d/</filename> by adjusting the <code>%install</code> section of the &DSCL; package's spec file:</para>
        <programlisting language="RPM Spec">%install
install -p -c -m 644 %{SOURCE2} $RPM_BUILD_ROOT%{?scl:%_root_sysconfdir}%{!?scl:%_sysconfdir}/logrotate.d/</programlisting>
      </step>
    </procedure>
  </section>
  <section id="sect-Software_Collection_varrun_Files_Support">
    <title>&DSCL; /var/run/ Files Support</title>
    <para>PID files are one example of files usually located underneath the <filename>/var/run/<replaceable>package_name</replaceable>/</filename> directory. When packaging PID files into your &DSCL;, you are strongly advised to use the <code>nfsmountable</code> macro and store the PID files in the following directory:</para>
    <screen><filename>/var/run/<replaceable>software_collection</replaceable>-<replaceable>package_name</replaceable>/</filename></screen>
    <para>where <replaceable>software_collection</replaceable> is the name of your &DSCL; and <replaceable>package_name</replaceable> is the name of the package included in your &DSCL;.</para>
    <para>Following this naming convention avoids file conflicts with the base system installation, while it makes it possible for your &DSCL; to use <filename>/var/run/</filename> features, for example the <systemitem>tmpfs</systemitem> file system for PID files.</para>
    <para>For more information on using the <code>nfsmountable</code> macro, see <xref linkend="sect-Using_Software_Collections_over_NFS" />.</para>
  </section>
  <section id="sect-Software_Collection_Lock_File_Support">
    <title>&DSCL; Lock File Support</title>
    <para>If you store your &DSCL;'s lock files within the <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/</filename> file system hierarchy, you can avoid any possible conflicts with the system versions of the applications or services that can be on the system.</para>
    <para>If you want to prevent &DSCL;'s applications or services from running while the system version of the respective application or service is running, make sure that your applications or services, which require a lock, write the lock to the system directory <filename>/var/lock/</filename> instead of the &DSCL;'s directory <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/var/lock/</filename>. In this way, your applications or services' lock file will not be overwritten. The lock file will not be renamed and the name stays the same as the system version.</para>
    <para>If you want your &DSCL;'s version of the application or service to run concurrently with the system version (when the &DSCL; version's resources will not conflict with the system version's resources), ensure that the applications or services write the lock to the &DSCL;'s directory <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/var/lock/</filename>.</para>
  <section id="Software_Collection_SysV_init_Lock_File_Support">
    <title>&DSCL; SysV init Lock File Support</title>
    <para>When a service is started by an init script, a lock file is touched in the <filename>/var/lock/subsys/</filename> directory with the same name as the init script. As discussed in <xref linkend="sect-Software_Collection_Initscript_Support" />, service names include a &DSCL; prefix. Use the same naming convention for files underneath <filename>/var/lock/subsys/</filename> to ensure that the lock file names do not conflict with the base system installation.</para>
  </section>
  </section>
  <section id="sect-Software_Collection_Configuration_Files_Support">
    <title>&DSCL; Configuration Files Support</title>
    <para>If you store your &DSCL;'s configuration files within the <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/</filename> file system hierarchy, you can avoid any possible conflicts with the system versions of the configuration files that can be present on the system.</para>
    <para>If you cannot store the configuration files within <filename>/&OPT;/<replaceable>&RH;</replaceable>/<replaceable>software_collection</replaceable>/</filename>, then ensure that you properly configure an alternative location for the configuration files. For many programs, this can be usually done at build or installation time. You can also define the <code>nfsmountable</code> macro to store the configuration files in the root file system.</para>
    <para>For more information about using the <code>nfsmountable</code> macro, see <xref linkend="sect-Using_Software_Collections_over_NFS" />.</para>
  </section>
  <section id="sect-Software_Collection_Kernel_Module_Support">
    <title>&DSCL; Kernel Module Support</title>
    <para>Because Linux kernel modules are normally tied to a particular version of the Linux kernel, you must be careful when you package kernel modules into a &DSCL;. This is because the package management system on &MAJOROS; does not automatically update or install an updated version of the kernel module if an updated version of the Linux kernel is installed. To make packaging the kernel modules into the &DSCL; easier, see the following recommendations. Ensure that:</para>
    <orderedlist>
      <listitem>
        <para>the name of your kernel module package includes the kernel version,</para>
      </listitem>
      <listitem>
        <para>the tag <code>Requires</code>, which can be found in your kernel module spec file, includes the kernel version and revision (in the format <code>kernel-<replaceable>version</replaceable>-<replaceable>revision</replaceable></code>).</para>
      </listitem>
    </orderedlist>
  </section>
  <section id="sect-Software_Collection_SELinux_Support">
    <title>&DSCL; SELinux Support</title>
    <para>Because &DSCL;s are designed to install the &DSCL; packages in an alternate directory, set up the necessary SELinux labels so that SELinux is aware of the alternate directory.</para>
    <para>If the file system hierarchy of your &DSCL; package imitates the file system hierarchy of the corresponding conventional package, you can run the <command>semanage fcontext</command> and <command>restorecon</command> commands to set up the SELinux labels.</para>
    <para>For example, if the <filename>/&OPT;/&RH;/software_collection_1/root/usr/</filename> directory in your &DSCL; package imitates the <filename>/usr/</filename> directory of your conventional package, set up the SELinux labels as follows:</para>
    <synopsis><command>semanage fcontext -a -e /usr /&OPT;/&RH;/software_collection_1/root/usr</command></synopsis>
    <synopsis><command>restorecon -R -v /&OPT;/&RH;/software_collection_1/root/usr</command></synopsis>
    <para>The commands above ensure that all directories and files in the <filename>/&OPT;/&RH;/software_collection_1/root/usr/</filename> directory are labeled by SELinux as if they were located in the <filename>/usr/</filename> directory.</para>
    <!--TODO: BZ#968360 <para>To use the <command>semanage fcontext</command> and <command>restorecon</command> commands in your &DSCL;, add the commands to the <code>%post</code> post-installation scriptlet in the &DSCL; spec file.</para>-->
    <section id="sect-Software_Collection_SELinux_Support-Red_Hat_Enterprise_Linux_7">
    <title>SELinux Support in Red Hat Enterprise Linux 7</title>
    <para>When packaging a &DSCL; for Red Hat Enterprise Linux 7, add the following commands to the <code>%post</code> section in the &DSCL; metapackage to set up the SELinux labels:</para>
    <synopsis><command>semanage fcontext -a -e /usr /&OPT;/&RH;/software_collection_1/root/usr</command></synopsis>
    <synopsis><command>restorecon -R -v /&OPT;/&RH;/software_collection_1/root/usr</command></synopsis>
    <synopsis><command>selinuxenabled &amp;&amp; load_policy || :</command></synopsis>
    <para>The last command ensures that the newly created SELinux policy is properly loaded, and that the files installed by a package in the &DSCL; are created with the correct SELinux context. By using this command in the metapackage, you do not need to include the <command>restorecon</command> command in all packages in the &DSCL;.</para>
    <para>Note that the <command>semanage fcontext</command> command is provided by the <package>policycoreutils-python</package> package, therefore it is important that you include <code>policycoreutils-python</code> in <code>Requires</code> for the &DSCL; metapackage.</para>
    </section>
  </section>
  <!--TODO: BZ#968360 <section id="sect-Software_Collection_SELinux_Support">
    <title>&DSCL; SELinux Support</title>
    <para>Because &DSCL;s are designed to install the &DSCL; packages in an alternate directory, set up the necessary SELinux labels so that SELinux is aware of the alternate directory.</para>
    <para>If the file system hierarchy of your &DSCL; package imitates the file system hierarchy of the corresponding conventional package, you can run the <command>semanage fcontext</command> and <command>restorecon</command> commands to set up the SELinux labels.</para>
    <para>For example, if the <filename>/&OPT;/&RH;/software_collection_1/root/usr/</filename> directory in your &DSCL; package imitates the <filename>/usr/</filename> directory of your conventional package, set up the SELinux labels as follows:</para>
    <synopsis>
      <command>semanage fcontext -a -e /usr /&OPT;/&RH;/software_collection_1/root/usr</command>
    </synopsis>
    <synopsis>
      <command>restorecon -R -v /&OPT;/&RH;/software_collection_1/root/usr</command>
    </synopsis>
    <para>The commands above ensure that all directories and files in the <filename>/&OPT;/&RH;/software_collection_1/root/usr/</filename> directory are labeled by SELinux as if they were located in the <filename>/usr/</filename> directory.</para>
    <para>To use the <command>semanage fcontext</command> and <command>restorecon</command> commands in your &DSCL;, add the commands to the <code>%post</code> section in the &DSCL; spec file.</para>
    <section id="sect-Using_restorecon_on_Red_Hat_Enterprise_Linux_6">
    <title>Using the restorecon command on Red Hat Enterprise Linux 6</title>
    <para>
      Note that when using the <command>semanage fcontext</command> and <command>restorecon</command> commands in the &DSCL; spec file, RPM will not set up the desired SELinux labels correctly for certain files if the following conditions are met:
    </para>
    <itemizedlist>
    <listitem>
    <para>
      you also install other packages as dependencies of the  &DSCL; metapackage, and
    </para>
    </listitem>
    <listitem>
      <para>
      these dependencies include files that apply for the desired SELinux context.
      </para>
    </listitem>
    </itemizedlist>
    <para>
      To set up the SELinux labels correctly for all files, make sure to run <command>restorecon</command> in the <code language="RPM Spec">%post</code> section of each dependency that include files applying for the desired SELinux context. For example, to run <command>restorecon</command> in the <code language="RPM Spec">%post</code> section of a <code>server</code> package in the <literal>mysql55</literal> &DSCL;, ensure that the &DSCL; spec file contains the following lines:
    </para>
    <programlisting language="RPM Spec">%post server
restorecon -R %{_scl_root} >/dev/null 2>&amp;1 || :
restorecon /etc/rc.d/init.d/%{scl_prefix}mysqld >/dev/null 2>&amp;1 || :</programlisting>
<procedure>
  <title>Setting up SELinux File Context Equivalency</title>
  <step>
    <para>
      In the <code language="RPM Spec">%post</code> section for the <package>runtime</package> subpackage of the &DSCL; metapackage, add the following lines:
    </para>
    <programlisting language="RPM Spec">%post runtime
if [ ! -f %{_sysconfdir}/selinux-equiv.created ]; then
  /usr/sbin/semanage fcontext -a -e / %{_scl_root}
  restorecon -R %{_scl_root}
  touch %{_sysconfdir}/selinux-equiv.created
fi
    </programlisting>
  </step>
  <step>
    <para>
      In the <code language="RPM Spec">%preun</code> section for the <package>runtime</package> subpackage of the &DSCL; metapackage, add the following lines:
    </para>
    <programlisting language="RPM Spec">%preun runtime
[ $1 = 0 ] &amp;&amp; rm -f %{_sysconfdir}/selinux-equiv.created || :
    </programlisting>
  </step>
  <step>
    <para>
      In the <code language="RPM Spec">%postun</code> section for the <package>runtime</package> subpackage of the &DSCL; metapackage, add the following lines:
    </para>
    <programlisting language="RPM Spec">%postun runtime
if [ $1 = 0 ]; then
  /usr/sbin/semanage fcontext -d %{_scl_root}
  restorecon -R %{_scl_root}
fi
    </programlisting>
  </step>
  <step>
    <para>
      Ensure that the <code language="RPM Spec">%files</code> section for the <package>runtime</package> subpackage of the &DSCL; metapackage contains the following lines:
    </para>
    <programlisting language="RPM Spec">%files runtime -f filesystem
%defattr(-,root,root,-)
%scl_files
%attr(0644,root,root) %verify(not md5 size mtime) %ghost %config(missingok,noreplace) %{_sysconfdir}/selinux-equiv.created
    </programlisting>
  </step>
  <step>
    <para>
      Ensure that the <code language="RPM Spec">%package runtime</code> section of the &DSCL; metapackage spec file contains the following lines:
    </para>
    <programlisting language="RPM Spec">%package runtime
Requires(post): libselinux policycoreutils-python
Requires(postun): libselinux policycoreutils-python
Requires(preun): libselinux policycoreutils-python
    </programlisting>
  </step>
</procedure>
    </section>
  </section>-->
</chapter>
