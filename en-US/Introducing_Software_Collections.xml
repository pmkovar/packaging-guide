<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chap-Introducing_Software_Collections">
  <title>Introducing &DSCL;s</title>
  <para>This chapter introduces you to the concept of &DSCL;s or &DSC;s for short.</para>
       <section id="sect-Why_to_Package_Software_with_RPM">
       <title>Why Package Software with RPM?</title>
   <para>The RPM Package Manager (RPM) is a package management system that runs on Red Hat Enterprise Linux. RPM makes it easier for you to distribute, manage, and update software that you create for Red Hat Enterprise Linux. Many software vendors distribute their software via a conventional archive file (such as a tarball). However, there are several advantages in packaging software into RPM packages. These advantages are outlined below.</para>
    <variablelist>
    <title>With RPM, you can:</title>
    <varlistentry>
     <term>Install, reinstall, remove, upgrade and verify packages.</term>
      <listitem><para>Users can use standard package management tools (for example <application>Yum</application> or <application>PackageKit</application>) to install, reinstall, remove, upgrade and verify your RPM packages.</para></listitem>
    </varlistentry>
    <varlistentry>
     <term>Use a database of installed packages to query and verify packages.</term>
      <listitem><para>Because RPM maintains a database of installed packages and their files, users can easily query and verify packages on their system.</para></listitem>
    </varlistentry>
    <varlistentry>
     <term>Use metadata to describe packages, their installation instructions, and so on.</term>
      <listitem><para>Each RPM package includes metadata that describes the package's components, version, release, size, project URL, installation instructions, and so on.</para></listitem>
          </varlistentry>
    <varlistentry>
     <term>Package pristine software sources into source and binary packages.</term>
      <listitem><para>RPM allows you to take pristine software sources and package them into source and binary packages for your users. In source packages, you have the pristine sources along with any patches that were used, plus complete build instructions. This design eases the maintenance of the packages as new versions of your software are released.</para></listitem>
      </varlistentry>
    <varlistentry>
     <term>Add packages to Yum repositories.</term>
      <listitem><para>You can add your package to a <application>Yum</application> repository that enables clients to easily find and deploy your software.</para></listitem>
      </varlistentry>
    <varlistentry>
     <term>Digitally sign your packages.</term>
      <listitem><para>Using a GPG signing key, you can digitally sign your package so that users are able to verify the authenticity of the package.</para></listitem>
      </varlistentry>
    </variablelist>
    <para>
    	For in-depth information on what is RPM and how to use it, refer to the <ulink url="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/index.html">Red Hat Enterprise Linux 6 Deployment Guide</ulink> or the <ulink url="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/index.html">Red Hat Enterprise Linux 5 Deployment Guide</ulink>.
    </para>
    </section>
  <section id="sect-What_Are_Software_Collections">
    <title>What Are &DSCL;s?</title>
    <para>With &DSCL;s, you can build and concurrently install multiple versions of the same software components on your system. &DSCL;s have no impact on the system versions of the packages installed by any of the conventional RPM package management utilities.</para>
    <variablelist>
    <title>&DSCL;s:</title>
      <varlistentry>
        <term>Do not overwrite system files</term>
        <listitem>
          <para>&DSCL;s are distributed as a set of several components, which provide their full functionality without overwriting system files.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Are designed to avoid conflicts with system files</term>
        <listitem>
          <para>&DSCL;s make use of a special file system hierarchy to avoid possible conflicts between a single &DSCL; and the base system installation.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Require no changes to the RPM package manager</term>
        <listitem>
          <para>&DSCL;s require no changes to the RPM package manager present on the host system.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Need only minor changes to the spec file</term>
        <listitem>
          <para>To convert a conventional package to a single &DSCL;, you only need to make minor changes to the package spec file.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Allow you to build a conventional package and a &DSCL; package with a single spec file</term>
        <listitem>
          <para>With a single spec file, you can build both the conventional package and the &DSCL; package.</para>
        </listitem>
      </varlistentry>
      <!--TODO: Make it less confusing.
      <varlistentry>
        <term>Allow you to use a spec file from one &DSCL; to build a different &DSCL;</term>
        <listitem>
          <para>You can use a single spec file from one &DSCL; to build a different &DSCL;.
</para>
        </listitem>
      </varlistentry>
      -->
      <varlistentry>
        <term>Uniquely name all included packages</term>
        <listitem>
          <para>With &DSCL;'s namespace, all packages included in the &DSCL; are uniquely named.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Do not conflict with updated packages</term>
        <listitem>
          <para>&DSCL;'s namespace ensures that updating packages on your system causes no conflicts.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Can depend on other &DSCL;s</term>
        <listitem>
          <para>Because one &DSCL; can depend on another, you can define multiple levels of dependencies.
</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
<section id="sect-Enabling_Support_for_Software_Collections">
<title>Enabling Support for &DSCL;s</title>
<para>To enable support for &DSCL;s on your system so that you can enable and build &DSCL;s, you need to have installed the packages <package>scl-utils</package> and <package>scl-utils-build</package>.</para>
<para>If the packages <package>scl-utils</package> and <package>scl-utils-build</package> are not already installed on your system, you can install them by typing the following at a shell prompt as root:</para>
<screen><command>yum install scl-utils scl-utils-build</command></screen>
<para>The <package>scl-utils</package> package provides the <application>scl</application> tool that lets you enable &DSCL;s on your system. For more information on enabling &DSCL;s, refer to <xref linkend="sect-Enabling_the_Software_Collection"/>.</para>
<para>The <package>scl-utils-build</package> package provides macros that are essential for building &DSCL;s. For more information on building &DSCL;s, refer to <xref linkend="sect-Building_a_Software_Collection_Locally"/>.</para>
</section>
  <section id="sect-The_File_System_Hierarchy">
    <title>The File System Hierarchy</title>
    <para>The root directory of &DSCL;s is normally located in the <filename>/&OPT;/</filename> directory to avoid possible conflicts between &DSCL;s and the base system installation. The use of the <filename>/&OPT;/</filename> directory is recommended by the Filesystem Hierarchy Standard (FHS).</para>
    <para>Below is an example of the file system hierarchy layout with two &DSCL;s, <replaceable>&DSCL; 1</replaceable> and <replaceable>&DSCL; 2</replaceable>:</para>
    <programlisting><replaceable>&OPT;</replaceable>
`-- <replaceable>&RH;</replaceable>
    |-- &DSCL; 1
    |   |-- &DSCL; root directory
    |   `-- &DSCL; scriptlets
    |
    `-- &DSCL; 2
        |-- &DSCL; root directory
        `-- &DSCL; scriptlets
</programlisting>
    <para>As you can see in the example above, each of the &DSCL;s directories contains two subdirectories: the &DSCL; root directory and a directory containing the &DSCL; scriptlets. For more information on the &DSCL; scriptlets, refer to <xref linkend="sect-Software_Collection_Scriptlets"/>.</para>
    </section>
    <section id="sect-The_Software_Collection_Root_Directory">
    	<title>The &DSCL; Root Directory</title>
    <para>You can change the location of the root directory by setting the <code>%_scl_prefix</code> macro in the spec file, as in the following example:</para>
    <programlisting language="RPM Spec">%_scl_prefix /opt/<replaceable>provider</replaceable></programlisting>
    <para>where <replaceable>provider</replaceable> is the provider (vendor) name registered, where applicable, with the Linux Foundation and the subordinated Linux Assigned Names and Numbers Authority (LANANA), in conformance with the Filesystem Hierarchy Standard.</para>
    <para>Each organization or project that builds and distributes &DSCL;s should use its own provider name, which conforms to the Filesystem Hierarchy Standard (FHS) and avoids possible conflicts between &DSCL;s and the base system installation.</para>
    <para>You are advised to make the file system hierarchy conform to the following layout:</para>
    <programlisting>/opt/<replaceable>provider</replaceable>/<replaceable>prefix-application-version</replaceable>/</programlisting>
    <para>For more information on the Filesystem Hierarchy Standard, see <ulink url="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</ulink>.</para>
    <para>For more information on the Linux Assigned Names and Numbers Authority, see <ulink url="http://www.lanana.org/">http://www.lanana.org/</ulink>.</para>
    </section>
  <section id="sect-The_Software_Collections_Prefix">
  	<title>The &DSCL; Prefix</title>
  	<para>
  		When naming your &DSCL;, it is important to prefix the name of your &DSCL; as described below in order to avoid possible name conflicts with the system versions of the packages that are part of your &DSCL;.
  	</para>
  	<para>
  		The &DSCL; prefix consists of two parts: 
  	</para>
  	<itemizedlist>
  		<listitem>
  			<para>
  				the <replaceable>provider</replaceable> part, which defines the provider name, and
			</para>
		</listitem>
		<listitem>
			<para>
				the name of the &DSCL; itself.
			</para>
		</listitem>
  	</itemizedlist>
  	<para>These two parts of the &DSCL; prefix are separated by an underscore (<literal>_</literal>), as in the following example:</para>
	<programlisting>myorganization_ruby193</programlisting>
	<para>In this example, <replaceable>myorganization</replaceable> is the provider name, and <replaceable>ruby193</replaceable> is the name of the &DSCL;.
	</para>
	</section>
	<section id="sect-Software_Collection_Package_Names">
		<title>&DSCL; Package Names</title>
  	<para>
  		The &DSCL; package name consists of two parts: 
  	</para>
  	<itemizedlist>
  		<listitem>
  			<para>
  				the <replaceable>prefix</replaceable> part, discussed in <xref linkend="sect-The_Software_Collections_Prefix" />, and
			</para>
		</listitem>
		<listitem>
			<para>
				the name and version number of the application that is a part of the &DSCL;.
			</para>
		</listitem>
  	</itemizedlist>
  	<para>These two parts of the &DSCL; package name are separated by a dash (<literal>-</literal>), as in the following example:</para>
	<programlisting>myorganization_ruby193-foreman-1.1</programlisting>
	<para>In this example, <replaceable>myorganization_ruby193</replaceable> is the prefix, and <replaceable>foreman-1.1</replaceable> is the name and version number of the application.</para>
    </section>
  <section id="sect-Software_Collection_Scriptlets">
    <title>&DSCL; Scriptlets</title>
    <para>The &DSCL; scriptlets are simple shell scripts that change the current system environment so that the group of packages in the &DSCL; is preferred over the corresponding group of conventional packages installed on the system.</para>
    <para>To utilize the &DSCL; scriptlets, use the <application>scl</application> tool. For more information on <application>scl</application>, refer to <xref linkend="sect-Enabling_the_Software_Collection"/>.</para>
  </section>
  <section id="sect-Package_Layout">
    <title>Package Layout</title>
    <para>Each &DSCL;'s layout consists of the meta package, which installs a subset of other packages, and a number of the &DSCL;'s packages, which are installed within the &DSCL; namespace.</para>
    <section id="sect-Meta_Package">
      <title>Meta Package</title>
      <para>Each &DSCL; includes a meta package, which installs a minimal subset of essential packages. For example, the essential packages can provide the Perl language interpreter, but no Perl extension modules. The meta package contains a basic file system hierarchy and delivers a number of the &DSCL;'s scriptlets.</para>
      <para>The purpose of the meta package is to make sure that all essential packages in the &DSCL; are properly installed and that it is possible to enable the &DSCL;.</para>
      <para>The meta package produces the following packages that are also part of the &DSCL;:</para>
      <variablelist>
        <varlistentry>
          <term>The main package: %scl</term>
          <listitem>
            <para>The main package in the &DSCL; contains dependencies of the base packages, which are included in the &DSCL;. The main package does not contain any files.</para>
            <para>For example, if the name of the &DSCL; is <literal>myorganization_ruby193</literal>, then the main package macro is expanded to:</para>
            <programlisting>myorganization_ruby193</programlisting>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>The runtime subpackage: <replaceable>name</replaceable>-runtime</term>
          <listitem>
            <para>The runtime subpackage in the &DSCL; owns the &DSCL;'s file system and delivers the &DSCL;'s scriptlets.</para>
            <para>For example, if the name of the &DSCL; is <literal>myorganization_ruby193</literal>, then the runtime subpackage macro is expanded to:</para>
            <programlisting>myorganization_ruby193-runtime</programlisting>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>The build subpackage: <replaceable>name</replaceable>-build</term>
          <listitem>
            <para>The build subpackage in the &DSCL; delivers the &DSCL;'s build configuration. The build subpackage is optional and can be excluded from the &DSCL;.</para>
            <para>For example, if the name of the &DSCL; is <literal>myorganization_ruby193</literal>, then the build subpackage macro is expanded to:</para>
            <programlisting>myorganization_ruby193-build</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>
</section>
<section id="sect-Creating_a_Meta_Package">
<title>Creating a Meta Package</title>
<itemizedlist>
	<title>When creating a new meta package:</title>
	<listitem>
		<para>
			You are advised to add <code language="RPM Spec">Requires: scl-utils-build</code> to the <package>build</package> subpackage.
		</para>
	</listitem>
	<listitem>
		<para>
			Add any macros you need to use to the <filename>macros.%{scl}-config</filename> file in the <package>build</package> subpackage.
		</para>
	</listitem>
	<listitem>
		<para>
			You are not required to use conditionals for &DSCL;-specific macros in the meta package.
		</para>
	</listitem>
	<listitem>
		<para>
			Consider specifying all packages in your &DSCL; that are essential for the &DSCL; run time as dependencies of the meta package. That way you can ensure that the packages are installed with the &DSCL; meta package.
		</para>
	</listitem>
	<listitem>
		<para> 
			Include any path redefinition that the packages in your &DSCL; may require in the <filename>enable</filename> scriptlet.
		</para>
		<para>
			For example, to run &DSCL; binary files, add <code language="RPM Spec">PATH=%{_bindir}\${PATH:+:\${PATH}}</code> to the <filename>enable</filename> scriptlet.
		</para>
	</listitem>
	<listitem>
		<para>
		 	Always make sure that the meta package spec file contains the <command>%setup -c -T</command> command in the <code language="RPM Spec">%prep</code> section, otherwise building the meta package will fail.
		 	</para>
		 	<para>
		 		This is because the <command>%setup</command> command defines and creates the <code language="RPM Spec">%buildsubdir</code> directory, which is normally used for storing temporary files at build time. If you do not define <command>%setup</command> in your meta package spec file, files in the <code language="RPM Spec">%buildsubdir</code> directory will be overwritten, causing the build to fail.
		 	</para>
	</listitem>
</itemizedlist>
<bridgehead id="bh-Example_of_the_Meta_Package">Example of the Meta Package</bridgehead>
<para>To get an idea of what a typical &DSCL; meta package looks like, see the following example:</para>
      <programlisting language="RPM Spec">%global scl software_collection
%scl_package %scl
%_scl_prefix /opt/myorganization

Summary: Package that installs %scl
Name: %scl_name
Version: 1
Release: 1%{?dist}
License: GPLv2+
Requires: %{scl_prefix}less
BuildRequires: scl-utils-build

%description
This is the main package for %scl Software Collection.

%package runtime
Summary: Package that handles %scl Software Collection.
Requires: scl-utils

%description runtime
Package shipping essential scripts to work with %scl Software Collection.

%package build
Summary: Package shipping basic build configuration
Requires: scl-utils-build

%description build
Package shipping essential configuration macros to build %scl Software Collection.

%prep
%setup -c -T

%install
rm -rf %{buildroot}
mkdir -p %{buildroot}%{_scl_scripts}/root
cat &gt;&gt; %{buildroot}%{_scl_scripts}/enable &lt;&lt; EOF
export PATH=%{_bindir}\${PATH:+:\${PATH}}
EOF
%scl_install

%files

%files runtime
%scl_files

%files build
%{_root_sysconfdir}/rpm/macros.%{scl}-config

%changelog
* Fri Aug 30 2013 John Doe &lt;jdoe@example.com&gt; 1-1
- Initial package
      </programlisting>
    </section>
<!--    <section id="sect-Packages_in_the_Software_Collection_Namespace">
      <title>Packages in the &DSCL; Namespace</title>
      <para>Besides the minimal subset of packages installed by the meta package, the &DSCL; also installs a number of packages that are part of the package collection itself.</para>
      <variablelist>
        <varlistentry>
          <term>&DSCL; package: <replaceable>name</replaceable>-<replaceable>pkgname</replaceable></term>
          <listitem>
            <para>The &DSCL; can contain a number of packages, which are included in the &DSCL; namespace and relocated to the &DSCL;'s file system hierarchy.</para>
            <para>For example, if the name of the &DSCL; is <literal>myorganization_ruby193</literal>, then the &DSCL;'s package name for the <package>ruby-1.9.3.352-2.1.&PKGOS;.x86_64.rpm</package> package is:</para>
            <programlisting>myorganization_ruby193-ruby-1.9.3.352-2.1.&PKGOS;.x86_64.rpm</programlisting>
            <para></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>-->
  </section>
  <section id="sect-Installing_a_Software_Collection">
    <title>Installing a &DSCL;</title>
    <para>To ensure that a &DSCL; is on your system, install the main meta package of the &DSCL;. You can use conventional tools like <application>Yum</application> or <application>PackageKit</application> for this task because &DSCL;s are fully compatible with the RPM Package Manager. For example, to install a &DSCL; named <code>software_collection_1</code>, run the following command:</para>
    <synopsis>
      <command>yum install software_collection_1</command>
    </synopsis>
    <para>This command will automatically install all the packages that are part of the &DSCL;. Also, if you install an application that depends on a &DSCL;, the &DSCL; will be installed along with the rest of the application's dependencies.</para>
<para>For detailed information on <application>Yum</application> and <application>PackageKit</application> usage, refer to the <ulink url="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/index.html">Red Hat Enterprise Linux 6 Deployment Guide</ulink>.</para>
  </section>
  <section id="sect-Listing_Installed_Software_Collections">
    <title>Listing Installed &DSCL;s</title>
    <para>To get a list of &DSCL;s that are currently installed on the system, run the following command:</para>
    <synopsis>
      <command>scl --list</command>
    </synopsis>
    </section>
  <section id="sect-Enabling_the_Software_Collection">
    <title>Enabling a &DSCL;</title>
    <para>The <application>scl</application> tool is used to enable a &DSCL; and to run applications in the &DSCL; environment.</para>
    <para>General usage of the <application>scl</application> tool can be described using the following syntax:</para>
    <synopsis>
      <command>scl</command>
      <replaceable>action</replaceable>
      <replaceable>software_collection_1</replaceable>
      <replaceable>software_collection_2</replaceable>
      <replaceable>command</replaceable>
    </synopsis>
    <section id="sect-Running_an_Application_Directly">
      <title>Running an Application Directly</title>
      <para>For example, to directly run <application>Perl</application> with the <option>--version</option> option in the &DSCL; named <application>software_collection_1</application>, execute the following command:</para>
      <synopsis>
        <command>scl enable software_collection_1 'perl --version'</command>
      </synopsis>
      <para>
      	Alternatively, you can create a wrapper script that shortens the commands for running applications in the &DSCL; environment. For more information on wrappers, see <xref linkend="sect-Packaging_Wrappers_for_Software_Collections" />.
      </para>
    </section>
    <section id="sect-Running_a_Shell_with_Multiple_Software_Collections_Enabled">
      <title>Running a Shell with Multiple &DSCL;s Enabled</title>
      <para>To run the <application>Bash</application> shell in the environment with multiple &DSCL;s enabled, execute the following command:</para>
      <synopsis>
        <command>scl enable software_collection_1 software_collection_2 bash</command>
      </synopsis>
      <para>The command above enables two &DSCL;s, named <application>software_collection_1</application> and <application>software_collection_2</application>, and runs a child process (subshell) of the shell. Running the command again then creates a subshell of the subshell.</para>
      <para>See <xref linkend="sect-Listing_Enabled_Software_Collections" /> for information on how to list enabled &DSCL;s for the current subshell.</para>
    </section>
    <section id="sect-Running_Commands_Stored_in_a_File">
      <title>Running Commands Stored in a File</title>
      <para>To execute a number of commands, which are stored in a file, in the &DSCL; environment, run the following command:</para>
      <synopsis>
        <command>cat cmd | scl enable software_collection_1 -</command>
      </synopsis>
      <para>The command above executes commands, which are stored in the <filename>cmd</filename> file, in the environment of the &DSCL; named <application>software_collection_1</application>.</para>
    </section>
  </section>
  <section id="sect-Listing_Enabled_Software_Collections">
    <title>Listing Enabled &DSCL;s</title>
    <para>
    	To get a list of &DSCL;s that are enabled in the current session, print the <envar>$X_SCLS</envar> environment variable by running the following command:
    </para>
    <synopsis><command>echo $X_SCLS</command>
    </synopsis>
  </section>
  <section id="sect-Uninstalling_a_Software_Collection">
    <title>Uninstalling a &DSCL;</title>
    <para>
    	You can use conventional tools like <application>Yum</application> or <application>PackageKit</application> when uninstalling a &DSCL; because &DSCL;s are fully compatible with the RPM Package Manager. For example, to uninstall all packages and subpackages that are part of a &DSCL; named <code>software_collection_1</code>, run the following command:</para>
    <synopsis>
      <command>yum remove software_collection_1\*</command>
    </synopsis>
    <para>
    	You can also use the <command>yum remove</command> command to remove the <application>scl</application> utility.
    </para>
    <para>For detailed information on <application>Yum</application> and <application>PackageKit</application> usage, refer to the <ulink url="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/index.html">Red Hat Enterprise Linux 6 Deployment Guide</ulink>.</para>
    <section id="sect-Uninstalling_all_Software_Collection_directories">
    <title>Uninstalling all &DSCL; directories</title>
    <para>
    	Keep in mind that the <command>yum remove</command> command does not uninstall directories provided by those &DSCL; packages and subpackages that are removed after the &DSCL; <package>runtime</package> subpackage is removed.
    </para>
    	<para>
    		To ensure that all directories are uninstalled, make those packages and subpackages depend on the <package>runtime</package> subpackage. To do so, add the following line to the spec file of each of those packages and subpackages:
    	</para>
    	<programlisting language="RPM Spec">%{?scl:Requires: %{scl}-runtime}</programlisting>
    	<para>
    		Adding the above line ensures that all directories provided by those packages and subpackages are removed correctly as long as the <package>runtime</package> subpackage does not depend on any of those packages and subpackages.
    	</para>
        </section>
  </section>
</chapter>
